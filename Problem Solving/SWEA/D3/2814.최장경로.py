# N개의 정점과 M개의 간선으로 구성된 가중치가 없는 무방향 그래프에서의 최장경로의 길이를 계산하자.
# 정점의 번호는 1번~N번까지 순서대로 부여되어 있다.
# 경로에는 같은 정점의 번호가 2번 이상 등장할 수 없으며, 경로 상의 인접한 들 사이에는 반드시 두 정점을 연결하는 간선이 존재해야 한다.
# 경로의 길이는 경로상에 등장하는 정점의 개수를 나타낸다.
# 입력: 노드 10개, 엣지 20개
# 출력:
# [아이디어]
# 이 문제의 조건은 무방향 그래프이다.
# 가능한 모든 경로에서 가장 긴 경우를 찾아야 한다.
# 가장 긴 경로가 모든 노드를 포함하는 경우가 아닌가?
# No!가장 긴 경로가 모든 노드를 포함할 수 없는 경우도 있다.
# 그렇다면, 각 노드별로 생각해볼 수 있을 것 같다!
# 출발지점!
# 모든 노드에서 출발해보고, 가장 긴 경로의 길이를 찾는다.
# 반복 or 재귀

#[stack 사용 - 반복]

#[재귀]
def f(n,k,c): #n방문노드, k전체노드, c경로에 포함된 노드 개수(n 미포함)
    global maxV
    if maxV < c+1:  #n을 포함한 경로의 길이가 더 길면
        maxV = c + 1 #갱신
    visited[n] = 1 #현재 경로에서 재진입 방지
    for i in range(1, k+1):     #모든 노드 i에 대해
        if adj[n][i]==1 and visited[i]==0:  #n에 인접이고 방문
            f(i, k, c+1)
        visited[n] = 0  #다른 경로에서 n으로 진입 허용

T=int(input())
for tc in range(1, T+1):
    N,M = map(int,input().split())
    adj = [[0]*(N+1) for _ in range(N+1)]
    visited = [0]*(N+1)
    maxV = 0
    for _ in range(M):
        n1, n2 = map(int,input().split())
        adj[n1][n2] = 1
        adj[n2][n1] = 1
    for i in range(1, N+1): #각 노드에서 출발해본다.
        f(i, N, 0)  #방문노드, 전체노드, 경로에 포함된 노드
    print('#{} {}'.format(tc,maxV))