# 그래프의 최소 비용 문제

## 1. 최소 신장 트리

- 신장트리

  : n개의 정점을 포함하는 무향 그래프에서 **n개의 정점과 n-1개의 간선**으로 구성된 트리

- 최소신장트리

  : 가중치 그래프에서 신장트리를 구성하는 **간선들의 가중치의 합이 최소인 신장트리**

  - 프림, 크루스칼 알고리즘이 존재

## 2. 프림 알고리즘

- 프림 알고리즘
  - 한 정점에 연결된 간선들 중 하나씩 선택하면서 최소 신장 트리를 만들어 가는 방식
    - 임의의 정점을 하나 선택해서 시작
    - 선택한 정점들과 인접하는 정점들 중에 최소 비용의 간선이 존재하는 정점 선택
    - 모든 정점이 선택될 때까지 두 번째 과정 반복
- 프림 알고리즘의 동작
  - 두 종류의 **상호배타집합**들 정보 필요
    - 트리 정점들
    - 비트리 정점들

```python
def MST_PRIM(G,s):	#G:그래프, s:시작정점
    key=[INF]*N	#1.가중치를 무한대로 초기화
    pi=[None]*N	#2. 트리에서 연결될 부모 정점 초기화
    visited = [False]*N	#3. 방문여부 초기화
    key[s] = 0	#4. 시작 정점의 가중치를 0으로 설정
    
    for _ in range(N):	#5. 정점의 개수만큼 반복
        minIndex = -1
        min = INF
        for i in range(N):	#6. 방문 안한 정점중 최소 가중치 정점 찾기
            if not visited[i] and key[i] < min:
                min = key[i]
                minIndex = i
            visited[minIndex] = True	#7. 최소 가중치 정점 방문처리
            for v,val in G[minIndex]:	#8. 선택 정점의 인접한 정점
                if not visited[v] and val < key[v]:	#9. 
                    key[v] = val	#10. 가중치 갱신
                    pi[v] = minIndex	#11. 트리에서 연결될 부모 정점
```





## 3. 크루스칼 알고리즘

- 크루스칼 알고리즘
  - 최소 가중치 간선을 하나씩 선택해서 최소 신장 트리를 찾는 알고리즘
- 크루스칼 알고리즘의 동작 과정
  1. 최초, 모든 간선을 가중치에 따라 **오름차순**으로 정렬
  2. **가중치가 가장 낮은 간선부터 선택**하면서 트리 증가시킴
     - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택

```python
#트리들을 상호배타 집합으로 관리
def MST_KRUSKAL(G):
    mst = []	#1. 공집합
    
    for i in range(N):	#2.
        Make_Set(i)
        
    
    G.sort(key=lambda t:t[2])	#3. 가중치 기준으로 정렬
    
    mst_cost = 0	#4. MST 가중치
    
    while len(mst) < N-1:	#5.
        u, v, val = G.pop(0)	#6. 최소 가중치 간선 가져오기
        if Find_Set(u) != Find_Set(v)	#7.
        	Union(u,v)	#8.
            mst.append((u,v))	#9. 트리에 (u,v) 추가
            mst_cost += val
```

- 간선 선택 과정에서 생성되는 트리를 관리하기 위해 **상호 배타 집합 사용**
  - 트리에 속한 노드들은 자신을 루트로 하는 **서브트리의 높이를 랭크라는 이름으로 저장**
- 선택한 간선으로 두 개의 트리가 한 개의 트리로 합쳐질 때 **각 트리에 해당하는 상호 배타 집합을 Union 연산으로 합침**
  - 랭크 값이 작은 트리를 랭크 값이 큰 트리의 서브트리로 포함시킬 경우 **트리에  포함된 노드들의 랭크 값 수정 불필요**



## 4. 최단 경로

- 최단 경로

  - 간선의 가중치가 있는 유향 그래프에서 두 정점 사이의 경로들 중 **간선의 가중치의 합이 최소인 경로**
    - 단일 시작점 최단 경로 문제
      - 다익스트라 알고리즘
      - 벨만-포드 알고리즘
    - 모든 쌍 최단 경로 문제
      - 플로이드-워샬 알고리즘

  

## 5. 다익스트라 알고리즘

- 다익스트라 알고리즘

  - 시작정점에서 거리가 최소인 정점부터 선택해 나가면서 **최단 경로를 구하는 방식**
  - 탐욕기법을 사용한 알고리즘, 최소 시장 트리를 구하는  prim 알고리즘과 유사.
  - 시작정점(r)에서 끝 정점(t)까지 **최단 경로에 정점 x가 존재**

- 다익스트라 알고리즘 동작과정

  ```python
  #D: 출발점에서 각 정점까지 최단 경로 가중치 합을 저장
  #P: 최단 경로 트리 저장
  def Dijkstra(G,r):	#G:그래프, r:시작정점
      D=[INF]*N	#1
      P=[None]*N	#2
      visited = [False]*N	#3
      D[r]=0	#4
      
      for _ in range(N):	#5
          minIndex = -1
          min = INF
          for i in range(N):	#6
              if not visited[i] and D[i] < min:
                  min = D[i]
                  minIndex = i
          visited[minIndex] = True	#7
          for v,val in G[minIndex]:	#8
              if not visited[v] and D[minIndex] + val < D[v]:	#9
                  D[v] = D[minIndex] + val	#10
                  P[v] = minIndex	#11
  ```

  

- 벨만-포드 알고리즘
  - **음의 가중치를 포함**하는 그래프에서 최단 경로를 구함
  - 출발점에서 각 정점까지 **간선 하나로 구성된 경로만 고려**해서 최단 경로를 구함
  - **최대 간선 두 개까지 고려**해서 최단 경로를 구해나가서 **최대 간선 n-1개까지 고려**한 경로들에서 최단 경로를 구함(n은 정점의 개수)
  - 다익스트라에 비해 **많은 시간 소요**

