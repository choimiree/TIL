# 탐욕 알고리즘

## 탐욕 알고리즘의 수행 과정

1. 해 선택
   - 최적해를 구한 뒤, 부분 해 집합에 추가
2. 실행 가능성 검사 실시
   - 새로운 부분 해 집합의 실행가능 여부 확인
   - 문제의 제약 조건 위반을 검사
3. 해 검사
   - 새로운 부분 해 집합이 문제의 해가 되는지 확인
   - 전체 문제의 해가 완성되지 않았다면 **1의 해 선택부터 다시 시작**



### 동전 거스름돈 문제

Q) 손님이 지불한 금액에서 물건값을 제한 차액을 지불하는 문제. 어떻게 하면 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

sol) 1. 해 선택 단계 - 가장 좋은 해 선택. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어들므로 **현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가**

2. 실행 가능성 검사 - **거스름돈**이 손님에게 내드려야 할 **액수를  초과하는지 확인**, 초과할 경우 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가서 현재보다 한 단계 작은 단위의 동전 추가
3. 해 검사 - **거스름돈 문제의 해** = 손님에게 내드려야하는 거스름돈의 액수. 거스름돈을 확인해서 액수에 모자라면 다시 1로 돌아가서 거스름돈에 추가할 동전을 고른다.

- 탐욕적 방법을 최적해를 구할 수 없기 때문에 완전검색으로 최적해를 찾는다.



### 배낭 문제

Q) 도둑은 부자들의 값진 물건들을 훔치기 위해 보관 창고에 침입. 배낭에 담아올거고, 도둑은 배낭은 담을 수 있는 물건의 총 무게(W)가 정해져 있음. 창고에는 여러개(n개)의 물건들이 있고, 각각의 물건에는 무게와 값이 정해져 있음. 배낭이 수용할 수 있는 무게를 초과하지 않으면서, 값의 총합이 최대가 되도록 선택하려면?

sol)

S = {i1, i2, i3, ... , in}, 물건들의 집합

wi : itemi의 무게, Pi=itemi의 값

W: 배낭이 수용가능한 총 무게

> 물건무게의 합이 배낭 무게를 초과하지 않고, 물건들 가치의 합이 최대가 되는 부분집합을 결정하는 문제!

- 0-1 배낭문제: 배낭에 물건을 통째로 담아야 하는 문제. **물건을 쪼갤 수 없음**
- Fractional 배낭문제: 물건을 부분적으로 담는 것이 가능. **물건을 쪼갤 수 있음.**

- 0-1 배낭문제에 대한 완전 검색 방법

  - 모든 부분집합 구함
  - 총 무게가 배낭무게 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 집합 선택
  - 물건의 개수가 증가하면 시간복잡도가 지수적으로 증가.
    - 원소의 수 n인 집합인 부분집합의 수 2^n

- 0-1 배낭문제에 대한 탐욕적 방법1

  - 값이 비싼 물건부터 채움
  - W=30kg
  - 탐욕적 방법의 결과: 물건 1 - 25kg, 10만원
  - 최적해: 물건2, 물건3 - 20kg, 14만원

  => 최적해 구할 수 없음.

- 0-1 배낭문제에 대한 탐욕적 방법 2

  - 무게가 가벼운 물건부터 채움
  - W=30kg
  - 탐욕적 방법의 결과: 물건2+물건3-14만원
  - 최적해: 물건1-15만원

  => 최적해 구할 수 없음

- 0-1 배낭문제에 대한 탐욕적 방법 3

  - 무게 당 값이 높은 순서로 물건 채움
  - W=30kg
  - 탐욕적 방법: 물건1, 물건3 - 190만원
  - 최적해: 물건2, 물건3 - 200만원

  => 탐욕적 방법으로는 최적해 구할 수 없음!

- Fractional 배낭문제

  - 물건의 일부를 잘라서 담을 수 있음
    - 탐욕적 방법으로 최적해 구할 수 있음!
  - 탐욕적인 방법
    - 물건1 + 물건3 + 물건2의 절반 - 30kg, 220만원
  - 물건을 잘라서 담는 경우 -> 탐욕알고리즘으로 최적해를 구할 수 있음 -> 최적해는 이상적으로 구할 수 있는 최대가치



###  활동 선택 문제

- 회의실 배정 문제: 이번주 금요일에 사용가능한 회의실은 하나만 존재. 회의 시간이 겹치는 회의들은 동시에 개최 불가능. 가능한 많은 회의가 열리기 위해서 회의들을 어떻게 배정해야 할까?
- 회의실 배정 문제 - 활동 선택 문제

```
- 시작시간과 종료 시간(si, fi)이 있는 n개의 활동들의 집합
- A={a1, a2, ..., an}, 1<=i<=n에서 서로 겹치지 않는 최대 개수의 활동들의 집하블 구하는 문제
```

- 회의 시간이 서로 겹치지 않는 최대 개수의 활동들의 집합을 구하는 문제.

```
양립 가능한 활동들의 크기가 최대가 되는 S0,n+1의 부분집합을 선택하는 문제
```

- 종료시간순으로 활동들 정렬
- S0,n+1는 **a0의 종료시간**부터 **an+1의 시작시간 **사이에 포함된 활동들
- S0,n+1={a1~a10}



- 탐욕 기법 적용

  - 공집합이 아닌 문제 Si,j가 있고 Si,j에 속한 활동 am은 종료시간이 가장 빠른 활동

    - 문제 Si,j에서 종료시간이 가장 빠른 활동 am을 선택
    - Si,m은 공집합이므로, am을 선택하면 공집합이 아닌 하위문제 Sm,j가 남음

    => 1,2 과정 반복

  - Si,j를 풀기 위해서!

    - 종료 시간이 가장 빠른 am 선택
    - Si,j = {am} U Sm,j의 해집합

  - 탐욕기법 알고리즘

  ```python
  A: 정렬된 활동들의 집합
  S: 선태된 활동들의 집합
  si: 시작시간, fi: 종료 시간, 1<=i<=n
  S = {a1}	#첫번째활동(a1)을 선택하고 해집합에 포함
  j = 1
  for i in range(2, n+1):
      if si >= fj:	#선택한 활동(a1)의 종료시간보다 빠른 시작 시간을 가지는 활동을 모두 제거
          S = S U {ai}
          j = i
  ```

  - 재귀 알고리즘

  ```python
  A: 정렬된 활동들의 집합
  S: 선택된 활동들의 집합
  si: 시작시간, fi: 종료 시간, 1<=i<=n
  
  Recursive_Selection(i,j):
      m=i+j
      while m <= j and sm < fi:	#종료시간이 가장 빠른 활동 선택
          m = m+1
      if m <= j: return{am} U Recursive_Selection(m,j)
      else: return {}	#공집합
      
  ```

- 탐욕 기법 검증

  - 탐욕 알고리즘이 최적해를 구한다는 것에 대한 증명
    - 탐욕적 선택 속성
      - 탐욕적 선택은 항상 안전하다는 것을 보여야 함
    - 최적 부분 구조
      - 하나의 선택을 하면 풀어야할 하위 문제가 남음
      - [원문제의 최적해 = 탐욕적 선택 + 하위문제의 최적해]임을 증명
    - **종료시간이 가장 빠른 활동** am을 **선택**하는 것은 **항상 안전**
      - 전체 활동들의 집합 Si,j에서 양립 가능한 최대 크기의 부분 집합 Ai,j가 있음
      - ak는 Ai,j에 속한 종료 시간이 가장 빠른 활동
      - 만약, ak = am이면 최대 크기 부분집합에 포함
      - 만약, ak != am이면 Ai,j에서 ak를 제거하고 am을 추가
      - 종료시간이 가장 빠른 활동 선택하는 것이 가장 안전
    - **활동 선택 문제의 해** = 탐욕적 선택 + 하위문제의 최적해
      - Si,j에서 am을 선택하면 하위 문제 Si,m과 Sm,j 존재
      - Si,m은 공집합, am을 선택한다는 것은 부분문제 Sm,j만이 고려해야할 활동이 존재하는 부분 문제임.
      - 만약 그게 아니라면, Si,m에 속하는 활동 ak가 있다면 am보다 종료시간이 빠르다는 것을 의미. 이는 가장 빠른 종료시간 am선택한 것과 모순. 그래서 Si,m은 고려할 필요 없는 공집합

- 탐욕 기법과 동적 계획법의 비교

  - 탐욕 기법: 매단계에서 가장 좋아보이는 것을 빠르게 선택,하위문제 풀기 전에 선택, 탑다운,일반적으로 빠르고 간결.
  - 동적 계획법: 하위문제의 해를 기반으로 선택, 하위문제 우선 해결, 바텀업, 느리고 복잡.



### Baby-Gin 다시보기

- 탐욕 기법을 통한 베이비진 문제 해결
  - 6개의 숫자는 6자리의 정수 값으로 입력되며 카운트 리스트에 저장
    - 카운트 리스트는 0에서 9까지의 숫자의 빈도수를 저장하는 리스트
  - 카운트 리스트의 각 원소를 체크하여 런,트리플릿 및 베이비진 여부 판단
  - 탐욕 알고리즘 방법 적용
    - 카운트리스트에서 런과 트리플릿 중에 가능한것 조사
    - 조사에 사용한 데이터는 삭제
    - 남은 데이터를 다시 런과 트리플릿중에 가능한지 조사

- 대표적인 탐욕 기법의 알고리즘들
  - Prim - 그래프
  - Kruskal - 그래프
  - Dijkstra - 그래프
  - Huffman coding - 문자열



