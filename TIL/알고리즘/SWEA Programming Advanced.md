# SW 문제해결

# 알고리즘 복잡도

- 점근적 상한

  - O(Big-Oh) 표기

    

# 비트연산

- 1<<n
  - 2^n의 값을 가짐
  - 원소가 n개일 경우의 모든 부분집합의 수를 의미
  - Power set(모든 부분 집합)
    - 공집합과 자기 자신을 포함한 모든 부분집합
    - **각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산**하면 모든 부분집합의 수가 계산됨
- i & (1<<j)
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미



- 엔디안(Endianness)

  - 컴퓨터의 메모리와 같은 1차원의 공간에 여러개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍쳐마다 다름
  - 주의 사항
    - 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류를 발생시킬 수 있음
  - 빅 엔디안 : 보통 큰 단위가 앞에 나옴, 네트워크.
  - 리틀 엔디안 : 작은단위가 앞에 나옴, 대다수 데스크탑 컴퓨터

  

# 진수

- 자주 사용되는 진수들 - 2진수, 8진수, 10진수, 16진수

- 10진수를 타 진수로 변환하는 방법

- 컴퓨터에서의 음의 정수 표현 방법

  - 1의 보수: 부호와 절대값으로 표현된 값을 부호 비트를 제외 한 나머지 비트들을 0은 1로, 1은 0로 변환
  - 2의 보수: 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더함

  

# 실수

- 유효 숫자

- 컴퓨터는 실수를 근사적으로 표현

  - 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장 
    - 근사값으로 저장될 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴

- 실수 자료형의 유효 자릿수

  - 32 비트 실수형 유효자릿수(십진수) -> 6
  - 64 비트 실수형 유효자릿수(십진수) -> 15

  

# 완전 검색 기법

- Baby-Gin 문제

  - 0~9 사이의 숫자 카드에서 임의의 카드 6장 뽑음
  - 3장의 카드가 연속적인 번호를 갖는 경우 런(Run)
  - 3장의 카드가 동일한 번호를 갖는 경우 트리플릿(Triplete)

- 완전 검색

  - 문제의 해를 얻기 위해 **가능한 모든 경우들을 나열해 보고 확인**하는 기법
    - 고지식한 방법, 생성 및 테스트
    - Brute-force의 force의 의미는 사람보다는 컴퓨터의 힘을 의미
  - 문제를 해결하기 위한 간단하고 쉬운 접근법
    - 상대적으로 **빠른 시간에 문제 해결(알고리즘 설계) 가능**
  - 대부분의 문제에 적용 가능
  - 문제에 포함된 자료(요소, 인스턴스)의 크기가 작을 경우 유용

- 고지식한 검색(순차 검색)

  - 자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행
  - 결과: 탐색 성공/ 실패

  ```python
  def sequentialSearch(a, n, key):
      i = 0
      while i < n and a[i] != key:
          i = i + 1
      if i < n:
          return i #성공
      else:
          return -1 #실패
  ```

  

# 조합적 문제

- 순열

  - 서로다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

  - 서로 다른 n개 중 r개를 택하는 순열 표현

    `nPr`

  - nPr의 식 성립

    `nPr = n x (n-1) x (n-2) x K x (n-r+1)`

  - nPn = n!이라고 표기하며 n Factorial이라 부름

    `n! = n x (n-1) x (n-2) x K x 2 x 1`

  - ex) 순서화된 요소들의 집합에서 최선의 방법을 찾는것과 관련됨

    - 순회 외판원 문제
      - 여러 도시들이 있고 한 도시에서 다른 도시로 이동하는 비용이 모두 주어짐
      - 출발 도시에서 시작해서 다른 모든 도시들을 단 한 번만 방문하고 출발. 도시로 돌아오는 최소 비용의 이동경로를 구하는 문제
      - 방문할 도시들을 순서대로 나열하면 하나의 경로가 됨
    - 순회 외판원 문제에서 거쳐가야 할 도시가 n개라면 가능한 모든 경로는 n!만큼 존재(12!=479,001,600)

  - 단순하게 순열을 생성하는 방법

    - ex) {1,2,3}을 포함하는 모든 순열을 생성하는 함수

    ```python
    #동일한 숫자가 포함되지 않았을 때, 각자리 수 별로  for loop를 이용해서 구현
    for i1 in range(1, 4):
        for i2 in range(1, 4):
            if i2 != i1:
                for i3 in range(1, 4):
                    if i3 != i1 and i3 != i2:
                        print(i1,i2,i3)
    ```

    - Baby-Gin을 판별하는 프로그램은 여섯 개의 포루프를 중첩해서 모든 순열 만들어 냄

    - 일반적으로 **재귀 호출을 이용**해서 필요한 횟수 만큼 반복을 수행하면서 수열 생성.

    ```python
    #재귀 호출을 통한 순열 생성
    
    # a[]: 데이터가 저장된 리스트
    # n: 원소의 개수, k: 현재까지 선택된 원소의 수
    def perm(n,k):
        if k==n: #하나의 순열이 생성됨.
            print(a)	#원하는 작업 수행
        else:
            for i in range(k,n):
                a[k],a[i] = a[i], a[k]	#교환을 통한 선택
                perm(n, k+1)	#재귀 호출
                a[k],a[i] = a[i],a[k]	#이전 상태로 복귀
    ```

    ```python
    #파이썬 라이브러리를 활용한 순열
    import itertools
    mylist = [1,2,3]
    result = itertools.permutations(mylist)	#(mylist, 3) #r 생략시 기본값 리스트 크기
    print(list(result))
    ```

    ```python
    #파이썬의 라이브러리를 활용한 중복순열
    
    import itertools
    mylist = [1,2,3]
    result = itertools.product(mylist, repeat=3)
    print(list(result))
    ```

- 부분집합

  - 집합에 포함된 원소들을 선택하는 것
  - 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것
    - ex) 배낭 짐싸기
      - 배낭과 물건들의 집합이 주어지며, 배낭은 무게가 있고 아이템들은 각각 무게와 가치가 있음
      - 배낭에 담는 무게의 총합 < 배낭의 무게
      - 물건의 총합이 배낭의 무게를 초과하지 않으면서 가치의 합이 최대가 되는 물건들 선택하는 문제
  - N개의 원소를 포함한 집합
    - 자기 자신과 공집합 포함한 **모든 부분집합의 개수는 2^n 개**
    - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

  ```python
  #단순하게 모든 부분 집합 생성하는 방법
  #4개 원소를 포함한 집합에 대한 Power set 구하기
  arr = [2,3,4,5]	#실제 집합
  bit = [0] * len(arr)
  for i in range(2):
      bit[0] = i	#0번째원소
      for j in range(2):
          bit[1] = j	#1번재 원소
          for k in range(2):
              bit[2] = k	#2번째 원소
              for l in range(2):
                  bit[3] = l	#3번째 원소
                  print([arr[x] for x in range(len(bit)) if bit[x]])	#생성된 부분집합 출력
  ```

- 부분집합

  - 바이너리 카운팅

    - 원소 수에 해당하는 N개의 비트 열을 이용
    - i번째 비트 값이 1이면 i번째 원소가 포함되었음을 의미

    ```python
    arr = [2,3,4,5]
    n=len(arr)	#n: 원소의 개수
    
    for i in range(1<<n):	#1<<n: 부분집합의 개수
        for j in range(n):	#원소의 수만큼 비트를 비교함
            if i & (1<<j):	#i의 j번째 비트가 1이면 j번째 원소 출력
                print(arr[j], ened=",")
            print()
    ```

- 조합

  - 서로 다른 n개의 우너소 중 r개를 순서 없이 골라낸 것
  - `nCr = n-1Cr-1 + n-1Cr`

  ```python
  #재귀 호출을 이용한 조합 생성 알고리즘
  
  #an[]: n개의 원소를 가지고 있는 리스트
  #tr[]: 조합이 임시 저장될 r개의 크기의 리스트
  
  def comb(n,r):
      if r==0: print(tr)
      elif n < r: return
      else:
          tr[r-1] = an[n-1]
          comb(n-1, r-1)
          comb(n-1, r)
          
  ```

  ```python
  # 파이썬의 라이브러리를 활용한 조합
  
  import itertools
  mylist = [1,2,3]
  result = itertools.combinations(mylist, r=2)#r생략불가
  print(list(result))
  ```

  ```python
  #파이썬의 라이브러리를 활용한 중복조합
  
  import itertools
  mylist = [1,2,3]
  result = itertools.combinations_with_replacement(mylist, r=2) #r생략불가
  print(list(result))
  ```

  